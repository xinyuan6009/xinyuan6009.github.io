# AnySDK登陆实施文档
##流程图
![](media/14778252454218/14778254739515.jpg)

---
###许可校验 accessCheck(int appId,int channelId) 
**accessCheck(int appId,int channelId) **

```java
	//校验APPID是否合法
		validedAppId(appId)		
			boolean isInBlackList = getFromBlackList(appId){  //判断是否在黑名单
				if(getFromRedis()==null){ //从redis获取AppId的黑名单记录
					reloadFromdDb();//如果redis中不存在黑名单记录，从DBrelaod一次
				}
			}
	//校验Channel是否合法
		validedChannel(channel)
			boolean isInWhiteList = getFromWhiteList(appId){  //判断是否在黑名单
				if(getFromRedis()==null){ //从redis获取AppId的黑名单记录
					reloadFromdDb();//如果redis中不存在黑名单记录，从DBrelaod一次
				}
			}
```
####依赖服务
manager后台需要提供黑名单列表数据，为了降低服务之间的耦合性，这里白名单列表的获取方案如下：
appId黑名单数据和channel白名单数据单独存放在SDK自己的内部服务器中，当白名单黑名单数据出现变更时，SDK服务提供数据更新接口，manager后台在更新列表的同时调用这个接口，通知SDK刷新列表数据。
**flushBlackOrWhiteList(List<LogData> logDataList)**

```java
flushBlackOrWhiteList(List<LogData> logDataList)
	for(LogData data:logDataList){
		validate(data);		//数据校验  判断传入数据是否合法
		case(oprtype==0)
			saveBlackListLog(data);
		case(oprtype==1)
			saveWhiteListLog(data);		case(oprtype==2)
			updateLogStatue(data);
	}
//saveBlackListLog&&saveWhiteListLog都会调用saveLog()公共方法
saveLog(data);
	saveToDb();
	flushToRedis();
```	
####数据协议

```java
LogData{
	id			//记录ID 添加操作 ID为null 更新操作时，id必须有值
	appId	   //appId  添加黑名单时 appId必须有值
	channel	//添加channel白名单时  channel必须有值
	oprtype	//操作类型 0：添加appId黑名单  1:添加channel白名单 2:更新白名单黑名单状态
	statue	//appId黑名单或者channel白名单状态 0：封停 1：开启  默认开启
}
```
####注意项：
1·更新操作时，更新条件是记录ID，所以ID必传，如果ID没有值，报警并跳过记录
2·更新或者操作记录时，如果没有传入记录的status，那么sdk就会将记录更新或者记录为默认值

####问题：
1·根据设计文档，目前只看到批量插入操作文档，会不会有批量更新状态操作？如果没有，我这边是否需要预先兼容批量更新状态操作？
2·批量操作是否有操作上限？如果没有，会不会存在大批量操作？

####数据结构
mysql

| id | log_id | app_id | channel | status | create_time | desc |
| --- | --- | --- | --- | --- | --- | --- |

id:sdk库自增ID
logId:manager后台记录ID
appId:游戏ID
channel:渠道ID
status:0：封停 1：开启  默认开启
create_time:sdk库记录创建时间
desc:描述信息

redis
appId黑名单
key:anysdk_login_black_list_appId  value:1
channel白名单
key:anysdk_login_white_list_channel value:1

---
###登陆许可下发 accessGrant
功能 1·生成百度ID  2·生成accessToken
**accessGrant(int appId,int channel,int uid)**

```java
	//根据渠道ID和渠道用户ID 生成唯一的百度ID
	createBaiduId(channel,uid);
	 saveToDb(baiduUser);
	 flushToRedis(hash);
	//生成授权TOKEN
	createAccessToken(channel,uid);
	 saveToDb(token);
	 flushToRedis(hash);
	//记录授权日志
	saveAccessGrantLog();
```
	
####数据交互协议 json

####问题
1·生成的百度ID 对渠道下每一款游戏都适用么，也就是说渠道用户对应的百度ID是否与游戏有关？
2·授权Token是否存在互踢，如果存在，是本游戏互踢还是跨游戏互踢？
####数据结构
mysql	
(百度用户)
   
| id | sdk_uid | baidu_id | create_time |
| --- | --- | --- | --- |

(授权Token)
   
| id | sdk_uid | token | create_time |
| --- | --- | --- | --- |

(授权日志)
	
| id | channel | app_id | sdk_uid | baidu_id | token | create_time |
| --- | --- | --- | --- | --- | --- | --- |

	
redis
	百度用户信息 
	key:anysdk_login_user_baiduId value:hashmap
	登陆授权TOKEN(与游戏无关) 过期时间
	key:anysdk_login_token_baiduId value:tokenStr
	登陆授权TOKEN(与游戏相关)
	key:anysdk_login_token_appId_baiduId value:tokenStr
####baiduId生成算法(其他用户)
sdk+sdkUid+UUID+offset
####token生成算法
明文：tokenStr = baiduId+channelId+appId+sdkId+timestamp
密文：Token = "anySDK_"+md5(tokenStr)
//补充：rsa加密算法在获取公私秘钥的时候比较耗时，为了减少耗时，这里采用秘钥生成预处理

---
###登陆许可校验 tokenCheck

```java
tokenCheck(token)
	//校验用户是否合法
	validadBaiduUser(sdkUid,baiduId)
		if(getBaiduUserFromRedis(baiduId)!=null){
			return true;
		}
		return false;
	//校验Token是否合法
	validadBaiduUser();
		if(getAccessTokenFromRedis()!=null){
			return true;
		}
		return false;
	```
anySDK登陆这块主要的对接人@文龙，@金房




